// Reimplemented using ad-hoc types.
decimate :: Iterable a -> Integer -> Iterable a;
decimate xs n = {
  (ixs :: Iterable (a, Integer)) = index xs;
  // Pattern matching of ad-hoc types.
  // The pipe operator is the equivalent of Haskell's ($)
  (s :: { item :: a, index :: Integer } -> a) = \{ item: x } => x;
  (f :: { item :: a, index :: Integer } -> Bool) = \{ index: i } => i mod n != 0;
  return map s | filter f ixs;

  // One can declare local functions in a block using `where`.
  where 
  index :: Iterable a -> Iterable { item :: a, index :: Integer };
  index xs = {
    var (i :: Integer) = 0;
    for (x :: a) in xs {
    /* Creation of an ad-hoc type instance. */
      yield val { (item :: a) = x; (index :: Integer) = i; };
      i += 1;
    }
  };
};
