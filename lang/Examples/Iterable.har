value List a = {
  variant Empty = {
    isEmpty :: List a -> Bool;
    isEmpty = true;

    // Implementing iterate is a special case as compared to normal functions.
    // If we're to treat List a as an Iterable a, all variants must declare
    // an iterate function.
    iterate :: List a -> Generator a;
    iterate = return;;
  };
  
  variant Nonempty = {
    data = {
      head :: a;
      tail :: List a;
    }
    
    isEmpty :: List a -> Bool;
    isEmpty = false;

    iterate :: List a -> Generator a;
    iterate = {
      // The `this` identifier binds to the implicit first argument of a member function.
      var current = this;
      while not current.isEmpty {
        yield current.head;
        current := current.tail;
      }
    };
  };
};

// This can be generalised to Iterable a -> ().
printList :: List a -> sideeffect;
printList xs = {
  for val x :: a in xs {
    eval print x ();
  }
};

filter :: (a -> bool) -> Iterable a -> Iterable a;
filter f xs = {
  for val x :: a in xs {
    if f x {
	  yield x;
	}
  }
};

map :: (a -> b) -> Iterable a -> Iterable b;
map f xs = {
  for val x :: a in xs {
    yield f x;
  }
};

foldl :: (a -> b -> a) -> b -> Iterable a -> b;
foldl f acc xs = {
  var result :: b = acc;
  for val x :: a in xs {
    result := f x result;
  }
  return result;
};
